#!/usr/bin/env ruby

# frozen_string_literal: true

require 'uri'
require 'net/http'

require_relative '../lib/gdk'

$stdout.sync = true

FileNotFoundError = Class.new(StandardError)

GITLAB_ORG_URL = 'https://gitlab.com/gitlab-org'
GITLAB_URL = "#{GITLAB_ORG_URL}/gitlab"
GITLAB_SHELL_URL = "#{GITLAB_ORG_URL}/gitlab-shell"
GITLAB_PAGES_URL = "#{GITLAB_ORG_URL}/gitlab-pages"
GITALY_URL = "#{GITLAB_ORG_URL}/gitaly"
GITLAB_RUNNER_URL = "#{GITLAB_ORG_URL}/gitlab-runner"
GITLAB_UI_URL = "#{GITLAB_ORG_URL}/gitlab-ui"
GITLAB_DOCS_URL = "#{GITLAB_ORG_URL}/gitlab-docs"
GITLAB_ELASTICSEARCH_INDEXER_URL = "#{GITLAB_ORG_URL}/gitlab-elasticsearch-indexer"
GITLAB_METRICS_EXPORTER = "#{GITLAB_ORG_URL}/gitlab-metrics-exporter"

class RemoteToolVersionFile
  def initialize(base_url, ref: 'master', path: '', label_ref: '')
    @base_url = base_url
    @ref = ref
    @label_ref = label_ref
    @path = path.empty? ? '' : "#{path.gsub(%r{(^/*|/*$)}, '')}/"
  end

  def url
    @url ||= "#{base_url}/-/raw/#{ref}/#{path}.tool-versions"
  end

  def line_comment
    return url if label_ref.empty?

    "#{base_url} -> #{label_ref}"
  end

  private

  attr_reader :ref, :base_url, :path, :label_ref
end

HEADER_CONTENT = <<~CONTENT
  # support/asdf-combine generates this file from .tool-versions-gdk and the .tool-versions
  # files from projects the GDK manages.
  #
  # Do not modify this file directly.
  #
CONTENT

def gdk_root
  @gdk_root ||= GDK::Config.new.gdk_root
end

def http_get(url)
  uri = URI.parse(url)
  response = Net::HTTP.get_response(uri)
  raise FileNotFoundError, "Unable to get '#{url}'" unless response.instance_of?(Net::HTTPOK)

  response.body
end

def extract_software_from_content(content)
  content.lines.each_with_object({}) do |entry, object|
    next unless (match = entry.match(/^(?<software>\w+) (?<versions>.+)$/))

    yield [match, object]
  end
end

def read_tool_versions_from(origin, content)
  extract_software_from_content(content) do |match, object|
    object[match[:software]] = match[:versions].split.each_with_object({}) { |e, all| all[e] = [origin] }
  end
end

def optional_software
  @optional_software ||= GDK.config.asdf.optional_software
end

def read_tool_versions_optional_from(origin, content)
  extract_software_from_content(content) do |match, object|
    next unless optional_software[match[:software]]

    object[match[:software]] = match[:versions].split.each_with_object({}) { |e, all| all[e] = [origin] }
  end
end

def write_tool_versions_file(data)
  tool_versions_file.write("#{HEADER_CONTENT}#{data}\n")
end

def ref_from_remote_file_for_gitlab_project(file)
  http_get(url_for_remote_file_for_gitlab_project(file)).chomp
end

def url_for_remote_file_for_gitlab_project(file)
  "#{GITLAB_URL}/-/raw/master/#{file}"
end

def tool_versions_file
  @tool_versions_file ||= gdk_root.join('.tool-versions')
end

def tool_versions_gdk_file
  @tool_versions_gdk_file ||= gdk_root.join('.tool-versions-gdk')
end

def tool_versions_optional_file
  @tool_versions_optional_file ||= gdk_root.join('.tool-versions-optional')
end

def format_software_and_versions_data(data)
  output = []

  data.each do |software, version_and_origins|
    output << "# #{software}:"

    version_and_origins.each do |version, origins|
      output << "#   #{version}:"
      origins.each do |origin|
        output << "#     - #{origin}"
      end
    end

    output << '#'
    output << "#{software} #{version_and_origins.keys.join(' ')}"
    output << ''
  end

  output.join("\n")
end

def process_tool_versions_files(tool_versions_files, tool_versions_data, quiet: false)
  tool_versions_files.each do |entry|
    $stderr.print '.' unless quiet

    begin
      tool_versions_contents = http_get(entry.url)
    rescue FileNotFoundError
      warn("ERROR: #{url} does not exist.")
      next
    end

    tool_versions_data_for_entry = read_tool_versions_from(entry.line_comment, tool_versions_contents)

    tool_versions_data = merge_data(tool_versions_data_for_entry, tool_versions_data)
  end

  tool_versions_data
end

def merge_data(new_data, tool_versions_data)
  new_data.each do |software, versions|
    tool_versions_data[software] ||= {}
    versions.each do |version, origin|
      tool_versions_data[software][version] ||= []
      tool_versions_data[software][version] |= origin
    end
  end

  tool_versions_data
end

def main(tool_versions_files, quiet: false)
  tool_versions_data_from_gdk_file = read_tool_versions_from('.tool-versions-gdk', tool_versions_gdk_file.read)
  tool_versions_data_from_optional_file = read_tool_versions_optional_from('.tool-versions-optional', tool_versions_optional_file.read)

  tool_versions_data_from_gdk_file_and_optional = merge_data(tool_versions_data_from_optional_file, tool_versions_data_from_gdk_file)

  tool_versions_data = process_tool_versions_files(tool_versions_files, tool_versions_data_from_gdk_file_and_optional.clone, quiet: quiet).sort.each_with_object({}) do |(software, versions), all|
    # We only sort by newest version first *if* not defined in .tool-versions-gdk
    sorted_versions = if tool_versions_data_from_gdk_file_and_optional[software]
                        versions
                      else
                        versions.sort { |(x_version, _), (y_version, _)| Gem::Version.new(x_version) <=> Gem::Version.new(y_version) }.reverse
                      end

    all[software] = sorted_versions.to_h
  end

  formatted_data = format_software_and_versions_data(tool_versions_data)

  unless quiet
    warn("\n") unless quiet # adds a newline to stderr after the ... activity dots.
    warn("Writing the following to #{tool_versions_file}")
    warn '=' * 80
    warn

    puts formatted_data
  end

  write_tool_versions_file(formatted_data)
end

# ------------------------------------------------------------------------------

tool_versions_files = [
  RemoteToolVersionFile.new(GITLAB_URL),
  RemoteToolVersionFile.new(GITLAB_URL, path: 'workhorse'),
  RemoteToolVersionFile.new(GITLAB_SHELL_URL, ref: 'main'),
  RemoteToolVersionFile.new(GITLAB_SHELL_URL, ref: "v#{ref_from_remote_file_for_gitlab_project('GITLAB_SHELL_VERSION')}", label_ref: url_for_remote_file_for_gitlab_project('GITLAB_SHELL_VERSION')),
  RemoteToolVersionFile.new(GITLAB_PAGES_URL),
  RemoteToolVersionFile.new(GITLAB_PAGES_URL, ref: "v#{ref_from_remote_file_for_gitlab_project('GITLAB_PAGES_VERSION')}", label_ref: url_for_remote_file_for_gitlab_project('GITLAB_PAGES_VERSION')),
  RemoteToolVersionFile.new(GITALY_URL),
  RemoteToolVersionFile.new(GITALY_URL, ref: ref_from_remote_file_for_gitlab_project('GITALY_SERVER_VERSION'), label_ref: url_for_remote_file_for_gitlab_project('GITALY_SERVER_VERSION')),
  RemoteToolVersionFile.new(GITLAB_RUNNER_URL, ref: 'main'),
  RemoteToolVersionFile.new(GITLAB_UI_URL, ref: 'main'),
  RemoteToolVersionFile.new(GITLAB_DOCS_URL, ref: 'main'),
  RemoteToolVersionFile.new(GITLAB_ELASTICSEARCH_INDEXER_URL, ref: 'main'),
  RemoteToolVersionFile.new(GITLAB_ELASTICSEARCH_INDEXER_URL, ref: "v#{ref_from_remote_file_for_gitlab_project('GITLAB_ELASTICSEARCH_INDEXER_VERSION')}", label_ref: url_for_remote_file_for_gitlab_project('GITLAB_ELASTICSEARCH_INDEXER_VERSION')),
  RemoteToolVersionFile.new(GITLAB_METRICS_EXPORTER, ref: 'main'),
  RemoteToolVersionFile.new(GITLAB_METRICS_EXPORTER, ref: ref_from_remote_file_for_gitlab_project('GITLAB_METRICS_EXPORTER_VERSION'), label_ref: url_for_remote_file_for_gitlab_project('GITLAB_METRICS_EXPORTER_VERSION'))
].freeze

main(tool_versions_files, quiet: ARGV.include?('--quiet'))
